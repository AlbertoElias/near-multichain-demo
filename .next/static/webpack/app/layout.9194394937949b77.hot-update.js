"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/lib/bitcoin.ts":
/*!****************************!*\
  !*** ./src/lib/bitcoin.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bitcoin: function() { return /* binding */ Bitcoin; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bitcoinjs-lib */ \"(app-pages-browser)/./node_modules/bitcoinjs-lib/src/index.js\");\n/* harmony import */ var _lib_kdf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/kdf */ \"(app-pages-browser)/./src/lib/kdf.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n\n\nclass Bitcoin {\n    async deriveAddress(accountId, derivation_path) {\n        const publicKey = await (0,_lib_kdf__WEBPACK_IMPORTED_MODULE_1__.deriveChildPublicKey)((0,_lib_kdf__WEBPACK_IMPORTED_MODULE_1__.najPublicKeyStrToUncompressedHexPoint)(), accountId, derivation_path);\n        const address = await (0,_lib_kdf__WEBPACK_IMPORTED_MODULE_1__.uncompressedHexPointToBtcAddress)(publicKey, this.network);\n        return {\n            publicKey: Buffer.from(publicKey, \"hex\"),\n            address\n        };\n    }\n    async getBalance(address) {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/address/\").concat(address, \"/utxo\"));\n        const balance = response.data.reduce((acc, utxo)=>acc + utxo.value, 0);\n        return balance;\n    }\n    async createPayload(sender, receiver, satoshis) {\n        const utxos = await this.fetchUTXOs(sender);\n        const feeRate = await this.fetchFeeRate();\n        const psbt = new bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.Psbt({\n            network: this.network\n        });\n        let totalInput = 0;\n        await Promise.all(utxos.map(async (utxo)=>{\n            totalInput += utxo.value;\n            const transaction = await this.fetchTransaction(utxo.txid);\n            const inputOptions = transaction.outs[utxo.vout].script.includes(\"0014\") ? {\n                hash: utxo.txid,\n                index: utxo.vout,\n                witnessUtxo: {\n                    script: transaction.outs[utxo.vout].script,\n                    value: utxo.value\n                }\n            } : {\n                hash: utxo.txid,\n                index: utxo.vout,\n                nonWitnessUtxo: Buffer.from(transaction.toHex(), \"hex\")\n            };\n            psbt.addInput(inputOptions);\n        }));\n        psbt.addOutput({\n            address: receiver,\n            value: Number(satoshis)\n        });\n        const estimatedSize = utxos.length * 148 + 2 * 34 + 10;\n        const fee = Math.ceil(estimatedSize * (feeRate + 3));\n        const change = totalInput - Number(satoshis) - fee;\n        if (change > 0) {\n            psbt.addOutput({\n                address: sender,\n                value: change\n            });\n        }\n        return {\n            psbt,\n            utxos\n        };\n    }\n    async requestSignatureToMPC(wallet, contractId, path, btcPayload, publicKey) {\n        const { psbt, utxos } = btcPayload;\n        // Bitcoin needs to sign multiple utxos, so we need to pass a signer function\n        const sign = async (tx)=>{\n            const payload = Array.from(ethers__WEBPACK_IMPORTED_MODULE_3__.getBytes(tx)).reverse();\n            const [big_r, big_s] = await wallet.callMethod({\n                contractId,\n                method: \"sign\",\n                args: {\n                    payload,\n                    path,\n                    key_version: 0\n                },\n                gas: \"250000000000000\"\n            });\n            return this.reconstructSignature(big_r, big_s);\n        };\n        await Promise.all(utxos.map(async (_, index)=>{\n            await psbt.signInputAsync(index, {\n                publicKey,\n                sign\n            });\n        }));\n        psbt.finalizeAllInputs();\n        return psbt.extractTransaction().toHex();\n    }\n    reconstructSignature(big_r, big_s) {\n        const r = big_r.slice(2).padStart(64, \"0\");\n        const s = big_s.padStart(64, \"0\");\n        const rawSignature = Buffer.from(r + s, \"hex\");\n        if (rawSignature.length !== 64) {\n            throw new Error(\"Invalid signature length.\");\n        }\n        return rawSignature;\n    }\n    // This code can be used to actually relay the transaction to the Ethereum network\n    async relayTransaction(signedTransaction) {\n        let useProxy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        const proxy = useProxy ? \"https://corsproxy.io/?\" : \"\";\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(proxy).concat(this.chain_rpc, \"/tx\"), signedTransaction);\n        return response.data;\n    }\n    /**\n   * Converts a value from satoshis to bitcoins.\n   *\n   * @param {number} satoshi - The amount in satoshis to convert.\n   * @returns {number} The equivalent amount in bitcoins.\n   */ static toBTC(satoshi) {\n        return satoshi / 100000000;\n    }\n    /**\n   * Converts a value from bitcoins to satoshis.\n   *\n   * @param {number} btc - The amount in bitcoins to convert.\n   * @returns {number} The equivalent amount in satoshis.\n   */ static toSatoshi(btc) {\n        return Number(btc * 100000000);\n    }\n    /**\n   * Fetches the current fee rate from the Bitcoin network.\n   * This method queries the RPC endpoint for fee estimates and returns the fee rate\n   * expected for a transaction to be confirmed within a certain number of blocks.\n   * The confirmation target is set to 6 blocks by default, which is commonly used\n   * for a balance between confirmation time and cost.\n   *\n   * @returns {Promise<number>} A promise that resolves to the fee rate in satoshis per byte.\n   * @throws {Error} Throws an error if the fee rate data for the specified confirmation target is missing.\n   */ async fetchFeeRate() {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/fee-estimates\"));\n        const confirmationTarget = 6;\n        return response.data[confirmationTarget];\n    }\n    /**\n   * Fetches the Unspent Transaction Outputs (UTXOs) for a given Bitcoin address.\n   *\n   * @param {string} address - The Bitcoin address for which to fetch the UTXOs.\n   * @returns {Promise<Array<{ txid: string; vout: number; value: number }>>} A promise that resolves to an array of UTXOs.\n   * Each UTXO is represented as an object containing the transaction ID (`txid`), the output index within that transaction (`vout`),\n   * and the value of the output in satoshis (`value`).\n   */ async fetchUTXOs(address) {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/address/\").concat(address, \"/utxo\"));\n        const utxos = response.data.map((utxo)=>({\n                txid: utxo.txid,\n                vout: utxo.vout,\n                value: utxo.value,\n                script: utxo.script\n            }));\n        return utxos;\n    }\n    /**\n   * Fetches a Bitcoin transaction by its ID and constructs a transaction object.\n   * This function retrieves the transaction details from the blockchain using the RPC endpoint,\n   * then parses the input and output data to construct a `bitcoin.Transaction` object.\n   *\n   * @param {string} transactionId - The ID of the transaction to fetch.\n   * @returns {Promise<bitcoin.Transaction>} A promise that resolves to a `bitcoin.Transaction` object representing the fetched transaction.\n   */ async fetchTransaction(transactionId) {\n        const { data } = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/tx/\").concat(transactionId));\n        const tx = new bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.Transaction();\n        tx.version = data.version;\n        tx.locktime = data.locktime;\n        data.vin.forEach((vin)=>{\n            const txHash = Buffer.from(vin.txid, \"hex\").reverse();\n            const vout = vin.vout;\n            const sequence = vin.sequence;\n            const scriptSig = vin.scriptsig ? Buffer.from(vin.scriptsig, \"hex\") : undefined;\n            tx.addInput(txHash, vout, sequence, scriptSig);\n        });\n        data.vout.forEach((vout)=>{\n            const value = vout.value;\n            const scriptPubKey = Buffer.from(vout.scriptpubkey, \"hex\");\n            tx.addOutput(scriptPubKey, value);\n        });\n        data.vin.forEach((vin, index)=>{\n            if (vin.witness && vin.witness.length > 0) {\n                const witness = vin.witness.map((w)=>Buffer.from(w, \"hex\"));\n                tx.setWitness(index, witness);\n            }\n        });\n        return tx;\n    }\n    /**\n   * Initializes a new instance of the `Bitcoin` class.\n   *\n   * @param {string} chain_rpc - The URL of the Bitcoin Core RPC endpoint.\n   * @param {string} network - The network to use. Either \"mainnet\" or \"testnet\".\n   */ constructor(chain_rpc, network){\n        this.chain_rpc = chain_rpc;\n        this.network = network === \"testnet\" ? bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.networks.testnet : bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.networks.bitcoin;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sR0FBR0EsWUFBWSxZQUFZVixtREFBZ0IsQ0FBQ29ILE9BQU8sR0FBR3BILG1EQUFnQixDQUFDQSxPQUFPO0lBQzVGO0FBb05GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYml0Y29pbi50cz85MTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCAqIGFzIGV0aGVycyBmcm9tIFwiZXRoZXJzXCI7XG5pbXBvcnQgKiBhcyBiaXRjb2luIGZyb20gXCJiaXRjb2luanMtbGliXCI7XG5pbXBvcnQgeyBkZXJpdmVDaGlsZFB1YmxpY0tleSwgbmFqUHVibGljS2V5U3RyVG9VbmNvbXByZXNzZWRIZXhQb2ludCwgdW5jb21wcmVzc2VkSGV4UG9pbnRUb0J0Y0FkZHJlc3MgfSBmcm9tIFwiQC9saWIva2RmXCI7XG5cbmV4cG9ydCBjbGFzcyBCaXRjb2luIHtcbiAgY2hhaW5fcnBjOiBzdHJpbmc7XG4gIG5ldHdvcms6IGJpdGNvaW4uTmV0d29yaztcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgQml0Y29pbmAgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbl9ycGMgLSBUaGUgVVJMIG9mIHRoZSBCaXRjb2luIENvcmUgUlBDIGVuZHBvaW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIHVzZS4gRWl0aGVyIFwibWFpbm5ldFwiIG9yIFwidGVzdG5ldFwiLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2hhaW5fcnBjOiBzdHJpbmcsIG5ldHdvcms6IHN0cmluZykge1xuICAgIHRoaXMuY2hhaW5fcnBjID0gY2hhaW5fcnBjO1xuICAgIHRoaXMubmV0d29yayA9IG5ldHdvcmsgPT09IFwidGVzdG5ldFwiID8gYml0Y29pbi5uZXR3b3Jrcy50ZXN0bmV0IDogYml0Y29pbi5uZXR3b3Jrcy5iaXRjb2luO1xuICB9XG5cbiAgYXN5bmMgZGVyaXZlQWRkcmVzcyhhY2NvdW50SWQ6IHN0cmluZywgZGVyaXZhdGlvbl9wYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBkZXJpdmVDaGlsZFB1YmxpY0tleShuYWpQdWJsaWNLZXlTdHJUb1VuY29tcHJlc3NlZEhleFBvaW50KCksIGFjY291bnRJZCwgZGVyaXZhdGlvbl9wYXRoKTtcbiAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdW5jb21wcmVzc2VkSGV4UG9pbnRUb0J0Y0FkZHJlc3MocHVibGljS2V5LCB0aGlzLm5ldHdvcmspO1xuICAgIHJldHVybiB7IHB1YmxpY0tleTogQnVmZmVyLmZyb20ocHVibGljS2V5LCBcImhleFwiKSwgYWRkcmVzcyB9O1xuICB9XG5cbiAgYXN5bmMgZ2V0QmFsYW5jZShhZGRyZXNzOiBhbnkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgIGAke3RoaXMuY2hhaW5fcnBjfS9hZGRyZXNzLyR7YWRkcmVzc30vdXR4b2BcbiAgICApO1xuICAgIGNvbnN0IGJhbGFuY2UgPSByZXNwb25zZS5kYXRhLnJlZHVjZSgoYWNjOiBhbnksIHV0eG86IHsgdmFsdWU6IGFueTsgfSkgPT4gYWNjICsgdXR4by52YWx1ZSwgMCk7XG4gICAgcmV0dXJuIGJhbGFuY2U7XG4gIH1cblxuICBhc3luYyBjcmVhdGVQYXlsb2FkKHNlbmRlcjogYW55LCByZWNlaXZlcjogYW55LCBzYXRvc2hpczogYW55KSB7XG4gICAgY29uc3QgdXR4b3MgPSBhd2FpdCB0aGlzLmZldGNoVVRYT3Moc2VuZGVyKTtcbiAgICBjb25zdCBmZWVSYXRlID0gYXdhaXQgdGhpcy5mZXRjaEZlZVJhdGUoKTtcblxuICAgIGNvbnN0IHBzYnQgPSBuZXcgYml0Y29pbi5Qc2J0KHsgbmV0d29yazogdGhpcy5uZXR3b3JrIH0pO1xuXG4gICAgbGV0IHRvdGFsSW5wdXQgPSAwO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdXR4b3MubWFwKFxuICAgICAgICBhc3luYyAodXR4bzogeyB2YWx1ZTogbnVtYmVyOyB0eGlkOiBzdHJpbmc7IHZvdXQ6IHN0cmluZyB8IG51bWJlcjsgfSkgPT4ge1xuICAgICAgICAgIHRvdGFsSW5wdXQgKz0gdXR4by52YWx1ZTtcblxuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5mZXRjaFRyYW5zYWN0aW9uKHV0eG8udHhpZCk7XG4gICAgICAgICAgY29uc3QgaW5wdXRPcHRpb25zID0gdHJhbnNhY3Rpb24ub3V0c1t1dHhvLnZvdXQgYXMgbnVtYmVyXS5zY3JpcHQuaW5jbHVkZXMoXCIwMDE0XCIpID9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGFzaDogdXR4by50eGlkLFxuICAgICAgICAgICAgICBpbmRleDogdXR4by52b3V0IGFzIG51bWJlcixcbiAgICAgICAgICAgICAgd2l0bmVzc1V0eG86IHtcbiAgICAgICAgICAgICAgICBzY3JpcHQ6IHRyYW5zYWN0aW9uLm91dHNbdXR4by52b3V0IGFzIG51bWJlcl0uc2NyaXB0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1dHhvLnZhbHVlLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSA6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGhhc2g6IHV0eG8udHhpZCxcbiAgICAgICAgICAgICAgaW5kZXg6IHV0eG8udm91dCBhcyBudW1iZXIsXG4gICAgICAgICAgICAgIG5vbldpdG5lc3NVdHhvOiBCdWZmZXIuZnJvbSh0cmFuc2FjdGlvbi50b0hleCgpLCBcImhleFwiKSxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIHBzYnQuYWRkSW5wdXQoaW5wdXRPcHRpb25zKTtcbiAgICAgICAgfSlcbiAgICApO1xuXG4gICAgcHNidC5hZGRPdXRwdXQoe1xuICAgICAgYWRkcmVzczogcmVjZWl2ZXIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHNhdG9zaGlzKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGVzdGltYXRlZFNpemUgPSB1dHhvcy5sZW5ndGggKiAxNDggKyAyICogMzQgKyAxMDtcbiAgICBjb25zdCBmZWUgPSBNYXRoLmNlaWwoZXN0aW1hdGVkU2l6ZSAqIChmZWVSYXRlICsgMykpO1xuXG4gICAgY29uc3QgY2hhbmdlID0gdG90YWxJbnB1dCAtIE51bWJlcihzYXRvc2hpcykgLSBmZWU7XG4gICAgaWYgKGNoYW5nZSA+IDApIHtcbiAgICAgIHBzYnQuYWRkT3V0cHV0KHtcbiAgICAgICAgYWRkcmVzczogc2VuZGVyLFxuICAgICAgICB2YWx1ZTogY2hhbmdlLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHNidCwgdXR4b3MgfTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RTaWduYXR1cmVUb01QQyh3YWxsZXQ6IHsgY2FsbE1ldGhvZDogKGFyZzA6IHsgY29udHJhY3RJZDogYW55OyBtZXRob2Q6IHN0cmluZzsgYXJnczogeyBwYXlsb2FkOiBudW1iZXJbXTsgcGF0aDogYW55OyBrZXlfdmVyc2lvbjogbnVtYmVyOyB9OyBnYXM6IHN0cmluZzsgfSkgPT4gUHJvbWlzZUxpa2U8W2FueSwgYW55XT4gfCBbYW55LCBhbnldOyB9LCBjb250cmFjdElkOiBhbnksIHBhdGg6IGFueSwgYnRjUGF5bG9hZDogeyBwc2J0OiBhbnk7IHV0eG9zOiBhbnk7IH0sIHB1YmxpY0tleTogYW55KSB7XG4gICAgY29uc3QgeyBwc2J0LCB1dHhvcyB9ID0gYnRjUGF5bG9hZDtcblxuICAgIC8vIEJpdGNvaW4gbmVlZHMgdG8gc2lnbiBtdWx0aXBsZSB1dHhvcywgc28gd2UgbmVlZCB0byBwYXNzIGEgc2lnbmVyIGZ1bmN0aW9uXG4gICAgY29uc3Qgc2lnbiA9IGFzeW5jICh0eDogZXRoZXJzLmV0aGVycy5CeXRlc0xpa2UpID0+IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBBcnJheS5mcm9tKGV0aGVycy5nZXRCeXRlcyh0eCkpLnJldmVyc2UoKTtcbiAgICAgIGNvbnN0IFtiaWdfciwgYmlnX3NdID0gYXdhaXQgd2FsbGV0LmNhbGxNZXRob2QoeyBjb250cmFjdElkLCBtZXRob2Q6IFwic2lnblwiLCBhcmdzOiB7IHBheWxvYWQsIHBhdGgsIGtleV92ZXJzaW9uOiAwIH0sIGdhczogXCIyNTAwMDAwMDAwMDAwMDBcIiB9KTtcbiAgICAgIHJldHVybiB0aGlzLnJlY29uc3RydWN0U2lnbmF0dXJlKGJpZ19yLCBiaWdfcyk7XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB1dHhvcy5tYXAoYXN5bmMgKF86IGFueSwgaW5kZXg6IGFueSkgPT4ge1xuICAgICAgICBhd2FpdCBwc2J0LnNpZ25JbnB1dEFzeW5jKGluZGV4LCB7IHB1YmxpY0tleSwgc2lnbiB9KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHBzYnQuZmluYWxpemVBbGxJbnB1dHMoKTtcblxuICAgIHJldHVybiBwc2J0LmV4dHJhY3RUcmFuc2FjdGlvbigpLnRvSGV4KClcbiAgfVxuXG4gIHJlY29uc3RydWN0U2lnbmF0dXJlKGJpZ19yOiBzdHJpbmcsIGJpZ19zOiBzdHJpbmcpIHtcbiAgICBjb25zdCByID0gYmlnX3Iuc2xpY2UoMikucGFkU3RhcnQoNjQsIFwiMFwiKTtcbiAgICBjb25zdCBzID0gYmlnX3MucGFkU3RhcnQoNjQsIFwiMFwiKTtcblxuICAgIGNvbnN0IHJhd1NpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHIgKyBzLCBcImhleFwiKTtcblxuICAgIGlmIChyYXdTaWduYXR1cmUubGVuZ3RoICE9PSA2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmF3U2lnbmF0dXJlO1xuICB9XG5cbiAgLy8gVGhpcyBjb2RlIGNhbiBiZSB1c2VkIHRvIGFjdHVhbGx5IHJlbGF5IHRoZSB0cmFuc2FjdGlvbiB0byB0aGUgRXRoZXJldW0gbmV0d29ya1xuICBhc3luYyByZWxheVRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uOiBhbnksIHVzZVByb3h5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHByb3h5ID0gdXNlUHJveHkgPyBcImh0dHBzOi8vY29yc3Byb3h5LmlvLz9cIiA6IFwiXCI7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoXG4gICAgICBgJHtwcm94eX0ke3RoaXMuY2hhaW5fcnBjfS90eGAsXG4gICAgICBzaWduZWRUcmFuc2FjdGlvblxuICAgICk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbHVlIGZyb20gc2F0b3NoaXMgdG8gYml0Y29pbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzYXRvc2hpIC0gVGhlIGFtb3VudCBpbiBzYXRvc2hpcyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBhbW91bnQgaW4gYml0Y29pbnMuXG4gICAqL1xuICBzdGF0aWMgdG9CVEMoc2F0b3NoaTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHNhdG9zaGkgLyAxMDAwMDAwMDA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIGJpdGNvaW5zIHRvIHNhdG9zaGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYnRjIC0gVGhlIGFtb3VudCBpbiBiaXRjb2lucyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgZXF1aXZhbGVudCBhbW91bnQgaW4gc2F0b3NoaXMuXG4gICAqL1xuICBzdGF0aWMgdG9TYXRvc2hpKGJ0YzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE51bWJlcihidGMgKiAxMDAwMDAwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIGN1cnJlbnQgZmVlIHJhdGUgZnJvbSB0aGUgQml0Y29pbiBuZXR3b3JrLlxuICAgKiBUaGlzIG1ldGhvZCBxdWVyaWVzIHRoZSBSUEMgZW5kcG9pbnQgZm9yIGZlZSBlc3RpbWF0ZXMgYW5kIHJldHVybnMgdGhlIGZlZSByYXRlXG4gICAqIGV4cGVjdGVkIGZvciBhIHRyYW5zYWN0aW9uIHRvIGJlIGNvbmZpcm1lZCB3aXRoaW4gYSBjZXJ0YWluIG51bWJlciBvZiBibG9ja3MuXG4gICAqIFRoZSBjb25maXJtYXRpb24gdGFyZ2V0IGlzIHNldCB0byA2IGJsb2NrcyBieSBkZWZhdWx0LCB3aGljaCBpcyBjb21tb25seSB1c2VkXG4gICAqIGZvciBhIGJhbGFuY2UgYmV0d2VlbiBjb25maXJtYXRpb24gdGltZSBhbmQgY29zdC5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZlZSByYXRlIGluIHNhdG9zaGlzIHBlciBieXRlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBmZWUgcmF0ZSBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIGNvbmZpcm1hdGlvbiB0YXJnZXQgaXMgbWlzc2luZy5cbiAgICovXG4gIGFzeW5jIGZldGNoRmVlUmF0ZSgpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHt0aGlzLmNoYWluX3JwY30vZmVlLWVzdGltYXRlc2ApO1xuICAgIGNvbnN0IGNvbmZpcm1hdGlvblRhcmdldCA9IDY7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGFbY29uZmlybWF0aW9uVGFyZ2V0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBVbnNwZW50IFRyYW5zYWN0aW9uIE91dHB1dHMgKFVUWE9zKSBmb3IgYSBnaXZlbiBCaXRjb2luIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIEJpdGNvaW4gYWRkcmVzcyBmb3Igd2hpY2ggdG8gZmV0Y2ggdGhlIFVUWE9zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTx7IHR4aWQ6IHN0cmluZzsgdm91dDogbnVtYmVyOyB2YWx1ZTogbnVtYmVyIH0+Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgVVRYT3MuXG4gICAqIEVhY2ggVVRYTyBpcyByZXByZXNlbnRlZCBhcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdHJhbnNhY3Rpb24gSUQgKGB0eGlkYCksIHRoZSBvdXRwdXQgaW5kZXggd2l0aGluIHRoYXQgdHJhbnNhY3Rpb24gKGB2b3V0YCksXG4gICAqIGFuZCB0aGUgdmFsdWUgb2YgdGhlIG91dHB1dCBpbiBzYXRvc2hpcyAoYHZhbHVlYCkuXG4gICAqL1xuICBhc3luYyBmZXRjaFVUWE9zKGFkZHJlc3M6IGFueSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgYCR7dGhpcy5jaGFpbl9ycGN9L2FkZHJlc3MvJHthZGRyZXNzfS91dHhvYFxuICAgICk7XG5cbiAgICBjb25zdCB1dHhvcyA9IHJlc3BvbnNlLmRhdGEubWFwKCh1dHhvOiB7IHR4aWQ6IGFueTsgdm91dDogYW55OyB2YWx1ZTogYW55OyBzY3JpcHQ6IGFueTsgfSkgPT4gKHtcbiAgICAgIHR4aWQ6IHV0eG8udHhpZCxcbiAgICAgIHZvdXQ6IHV0eG8udm91dCxcbiAgICAgIHZhbHVlOiB1dHhvLnZhbHVlLFxuICAgICAgc2NyaXB0OiB1dHhvLnNjcmlwdCxcbiAgICB9KSk7XG4gICAgcmV0dXJuIHV0eG9zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYSBCaXRjb2luIHRyYW5zYWN0aW9uIGJ5IGl0cyBJRCBhbmQgY29uc3RydWN0cyBhIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICogVGhpcyBmdW5jdGlvbiByZXRyaWV2ZXMgdGhlIHRyYW5zYWN0aW9uIGRldGFpbHMgZnJvbSB0aGUgYmxvY2tjaGFpbiB1c2luZyB0aGUgUlBDIGVuZHBvaW50LFxuICAgKiB0aGVuIHBhcnNlcyB0aGUgaW5wdXQgYW5kIG91dHB1dCBkYXRhIHRvIGNvbnN0cnVjdCBhIGBiaXRjb2luLlRyYW5zYWN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2FjdGlvbklkIC0gVGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBmZXRjaC5cbiAgICogQHJldHVybnMge1Byb21pc2U8Yml0Y29pbi5UcmFuc2FjdGlvbj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYGJpdGNvaW4uVHJhbnNhY3Rpb25gIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGZldGNoZWQgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBhc3luYyBmZXRjaFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSWQ6IGFueSkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgYCR7dGhpcy5jaGFpbl9ycGN9L3R4LyR7dHJhbnNhY3Rpb25JZH1gXG4gICAgKTtcbiAgICBjb25zdCB0eCA9IG5ldyBiaXRjb2luLlRyYW5zYWN0aW9uKCk7XG5cbiAgICB0eC52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuICAgIHR4LmxvY2t0aW1lID0gZGF0YS5sb2NrdGltZTtcblxuICAgIGRhdGEudmluLmZvckVhY2goKHZpbjogeyB0eGlkOiBXaXRoSW1wbGljaXRDb2VyY2lvbjxzdHJpbmc+IHwgeyBbU3ltYm9sLnRvUHJpbWl0aXZlXShoaW50OiBcInN0cmluZ1wiKTogc3RyaW5nOyB9OyB2b3V0OiBhbnk7IHNlcXVlbmNlOiBhbnk7IHNjcmlwdHNpZzogV2l0aEltcGxpY2l0Q29lcmNpb248c3RyaW5nPiB8IHsgW1N5bWJvbC50b1ByaW1pdGl2ZV0oaGludDogXCJzdHJpbmdcIik6IHN0cmluZzsgfTsgfSkgPT4ge1xuICAgICAgY29uc3QgdHhIYXNoID0gQnVmZmVyLmZyb20odmluLnR4aWQsIFwiaGV4XCIpLnJldmVyc2UoKTtcbiAgICAgIGNvbnN0IHZvdXQgPSB2aW4udm91dDtcbiAgICAgIGNvbnN0IHNlcXVlbmNlID0gdmluLnNlcXVlbmNlO1xuICAgICAgY29uc3Qgc2NyaXB0U2lnID0gdmluLnNjcmlwdHNpZ1xuICAgICAgICA/IEJ1ZmZlci5mcm9tKHZpbi5zY3JpcHRzaWcsIFwiaGV4XCIpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgdHguYWRkSW5wdXQodHhIYXNoLCB2b3V0LCBzZXF1ZW5jZSwgc2NyaXB0U2lnKTtcbiAgICB9KTtcblxuICAgIGRhdGEudm91dC5mb3JFYWNoKCh2b3V0OiB7IHZhbHVlOiBhbnk7IHNjcmlwdHB1YmtleTogV2l0aEltcGxpY2l0Q29lcmNpb248c3RyaW5nPiB8IHsgW1N5bWJvbC50b1ByaW1pdGl2ZV0oaGludDogXCJzdHJpbmdcIik6IHN0cmluZzsgfTsgfSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB2b3V0LnZhbHVlO1xuICAgICAgY29uc3Qgc2NyaXB0UHViS2V5ID0gQnVmZmVyLmZyb20odm91dC5zY3JpcHRwdWJrZXksIFwiaGV4XCIpO1xuICAgICAgdHguYWRkT3V0cHV0KHNjcmlwdFB1YktleSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgZGF0YS52aW4uZm9yRWFjaCgodmluOiB7IHdpdG5lc3M6IGFueVtdOyB9LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAodmluLndpdG5lc3MgJiYgdmluLndpdG5lc3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB3aXRuZXNzID0gdmluLndpdG5lc3MubWFwKCh3OiBXaXRoSW1wbGljaXRDb2VyY2lvbjxzdHJpbmc+IHwgeyBbU3ltYm9sLnRvUHJpbWl0aXZlXShoaW50OiBcInN0cmluZ1wiKTogc3RyaW5nOyB9KSA9PiBCdWZmZXIuZnJvbSh3LCBcImhleFwiKSk7XG4gICAgICAgIHR4LnNldFdpdG5lc3MoaW5kZXgsIHdpdG5lc3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHR4O1xuICB9XG59Il0sIm5hbWVzIjpbImF4aW9zIiwiZXRoZXJzIiwiYml0Y29pbiIsImRlcml2ZUNoaWxkUHVibGljS2V5IiwibmFqUHVibGljS2V5U3RyVG9VbmNvbXByZXNzZWRIZXhQb2ludCIsInVuY29tcHJlc3NlZEhleFBvaW50VG9CdGNBZGRyZXNzIiwiQml0Y29pbiIsImRlcml2ZUFkZHJlc3MiLCJhY2NvdW50SWQiLCJkZXJpdmF0aW9uX3BhdGgiLCJwdWJsaWNLZXkiLCJhZGRyZXNzIiwibmV0d29yayIsIkJ1ZmZlciIsImZyb20iLCJnZXRCYWxhbmNlIiwicmVzcG9uc2UiLCJnZXQiLCJjaGFpbl9ycGMiLCJiYWxhbmNlIiwiZGF0YSIsInJlZHVjZSIsImFjYyIsInV0eG8iLCJ2YWx1ZSIsImNyZWF0ZVBheWxvYWQiLCJzZW5kZXIiLCJyZWNlaXZlciIsInNhdG9zaGlzIiwidXR4b3MiLCJmZXRjaFVUWE9zIiwiZmVlUmF0ZSIsImZldGNoRmVlUmF0ZSIsInBzYnQiLCJQc2J0IiwidG90YWxJbnB1dCIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJ0cmFuc2FjdGlvbiIsImZldGNoVHJhbnNhY3Rpb24iLCJ0eGlkIiwiaW5wdXRPcHRpb25zIiwib3V0cyIsInZvdXQiLCJzY3JpcHQiLCJpbmNsdWRlcyIsImhhc2giLCJpbmRleCIsIndpdG5lc3NVdHhvIiwibm9uV2l0bmVzc1V0eG8iLCJ0b0hleCIsImFkZElucHV0IiwiYWRkT3V0cHV0IiwiTnVtYmVyIiwiZXN0aW1hdGVkU2l6ZSIsImxlbmd0aCIsImZlZSIsIk1hdGgiLCJjZWlsIiwiY2hhbmdlIiwicmVxdWVzdFNpZ25hdHVyZVRvTVBDIiwid2FsbGV0IiwiY29udHJhY3RJZCIsInBhdGgiLCJidGNQYXlsb2FkIiwic2lnbiIsInR4IiwicGF5bG9hZCIsIkFycmF5IiwiZ2V0Qnl0ZXMiLCJyZXZlcnNlIiwiYmlnX3IiLCJiaWdfcyIsImNhbGxNZXRob2QiLCJtZXRob2QiLCJhcmdzIiwia2V5X3ZlcnNpb24iLCJnYXMiLCJyZWNvbnN0cnVjdFNpZ25hdHVyZSIsIl8iLCJzaWduSW5wdXRBc3luYyIsImZpbmFsaXplQWxsSW5wdXRzIiwiZXh0cmFjdFRyYW5zYWN0aW9uIiwiciIsInNsaWNlIiwicGFkU3RhcnQiLCJzIiwicmF3U2lnbmF0dXJlIiwiRXJyb3IiLCJyZWxheVRyYW5zYWN0aW9uIiwic2lnbmVkVHJhbnNhY3Rpb24iLCJ1c2VQcm94eSIsInByb3h5IiwicG9zdCIsInRvQlRDIiwic2F0b3NoaSIsInRvU2F0b3NoaSIsImJ0YyIsImNvbmZpcm1hdGlvblRhcmdldCIsInRyYW5zYWN0aW9uSWQiLCJUcmFuc2FjdGlvbiIsInZlcnNpb24iLCJsb2NrdGltZSIsInZpbiIsImZvckVhY2giLCJ0eEhhc2giLCJzZXF1ZW5jZSIsInNjcmlwdFNpZyIsInNjcmlwdHNpZyIsInVuZGVmaW5lZCIsInNjcmlwdFB1YktleSIsInNjcmlwdHB1YmtleSIsIndpdG5lc3MiLCJ3Iiwic2V0V2l0bmVzcyIsImNvbnN0cnVjdG9yIiwibmV0d29ya3MiLCJ0ZXN0bmV0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/bitcoin.ts\n"));

/***/ })

});