"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/bitcoin.ts":
/*!****************************!*\
  !*** ./src/lib/bitcoin.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bitcoin: function() { return /* binding */ Bitcoin; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/data.js\");\n/* harmony import */ var bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bitcoinjs-lib */ \"(app-pages-browser)/./node_modules/bitcoinjs-lib/src/index.js\");\n/* harmony import */ var _lib_kdf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/kdf */ \"(app-pages-browser)/./src/lib/kdf.ts\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n\n\n\nclass Bitcoin {\n    async deriveAddress(accountId, derivation_path) {\n        const publicKey = await (0,_lib_kdf__WEBPACK_IMPORTED_MODULE_1__.deriveChildPublicKey)((0,_lib_kdf__WEBPACK_IMPORTED_MODULE_1__.najPublicKeyStrToUncompressedHexPoint)(), accountId, derivation_path);\n        const address = await (0,_lib_kdf__WEBPACK_IMPORTED_MODULE_1__.uncompressedHexPointToBtcAddress)(publicKey, this.network);\n        return {\n            publicKey: Buffer.from(publicKey, \"hex\"),\n            address\n        };\n    }\n    async getBalance(address) {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/address/\").concat(address, \"/utxo\"));\n        const balance = response.data.reduce((acc, utxo)=>acc + utxo.value, 0);\n        return balance;\n    }\n    async createPayload(sender, receiver, satoshis) {\n        const utxos = await this.fetchUTXOs(sender);\n        const feeRate = await this.fetchFeeRate();\n        const psbt = new bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.Psbt({\n            network: this.network\n        });\n        let totalInput = 0;\n        await Promise.all(utxos.map(async (utxo)=>{\n            totalInput += utxo.value;\n            const transaction = await this.fetchTransaction(utxo.txid);\n            const inputOptions = transaction.outs[utxo.vout].script.includes(\"0014\") ? {\n                hash: utxo.txid,\n                index: utxo.vout,\n                witnessUtxo: {\n                    script: transaction.outs[utxo.vout].script,\n                    value: utxo.value\n                }\n            } : {\n                hash: utxo.txid,\n                index: utxo.vout,\n                nonWitnessUtxo: Buffer.from(transaction.toHex(), \"hex\")\n            };\n            psbt.addInput(inputOptions);\n        }));\n        psbt.addOutput({\n            address: receiver,\n            value: Number(satoshis)\n        });\n        const estimatedSize = utxos.length * 148 + 2 * 34 + 10;\n        const fee = Math.ceil(estimatedSize * (feeRate + 3));\n        const change = totalInput - Number(satoshis) - fee;\n        if (change > 0) {\n            psbt.addOutput({\n                address: sender,\n                value: change\n            });\n        }\n        return {\n            psbt,\n            utxos\n        };\n    }\n    async requestSignatureToMPC(wallet, contractId, path, btcPayload, publicKey) {\n        const { psbt, utxos } = btcPayload;\n        // Bitcoin needs to sign multiple utxos, so we need to pass a signer function\n        const sign = async (tx)=>{\n            const payload = Array.from(ethers__WEBPACK_IMPORTED_MODULE_3__.getBytes(tx)).reverse();\n            const [big_r, big_s] = await wallet.callMethod({\n                contractId,\n                method: \"sign\",\n                args: {\n                    payload,\n                    path,\n                    key_version: 0\n                },\n                gas: \"250000000000000\"\n            });\n            return this.reconstructSignature(big_r, big_s);\n        };\n        await Promise.all(utxos.map(async (_, index)=>{\n            await psbt.signInputAsync(index, {\n                publicKey,\n                sign\n            });\n        }));\n        psbt.finalizeAllInputs();\n        return psbt.extractTransaction().toHex();\n    }\n    reconstructSignature(big_r, big_s) {\n        const r = big_r.slice(2).padStart(64, \"0\");\n        const s = big_s.padStart(64, \"0\");\n        const rawSignature = Buffer.from(r + s, \"hex\");\n        if (rawSignature.length !== 64) {\n            throw new Error(\"Invalid signature length.\");\n        }\n        return rawSignature;\n    }\n    // This code can be used to actually relay the transaction to the Ethereum network\n    async relayTransaction(signedTransaction) {\n        let useProxy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        const proxy = useProxy ? \"https://corsproxy.io/?\" : \"\";\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].post(\"\".concat(proxy).concat(this.chain_rpc, \"/tx\"), signedTransaction);\n        return response.data;\n    }\n    /**\n   * Converts a value from satoshis to bitcoins.\n   *\n   * @param {number} satoshi - The amount in satoshis to convert.\n   * @returns {number} The equivalent amount in bitcoins.\n   */ static toBTC(satoshi) {\n        return satoshi / 100000000;\n    }\n    /**\n   * Converts a value from bitcoins to satoshis.\n   *\n   * @param {number} btc - The amount in bitcoins to convert.\n   * @returns {number} The equivalent amount in satoshis.\n   */ static toSatoshi(btc) {\n        return Number(btc * 100000000);\n    }\n    /**\n   * Fetches the current fee rate from the Bitcoin network.\n   * This method queries the RPC endpoint for fee estimates and returns the fee rate\n   * expected for a transaction to be confirmed within a certain number of blocks.\n   * The confirmation target is set to 6 blocks by default, which is commonly used\n   * for a balance between confirmation time and cost.\n   *\n   * @returns {Promise<number>} A promise that resolves to the fee rate in satoshis per byte.\n   * @throws {Error} Throws an error if the fee rate data for the specified confirmation target is missing.\n   */ async fetchFeeRate() {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/fee-estimates\"));\n        const confirmationTarget = 6;\n        return response.data[confirmationTarget];\n    }\n    /**\n   * Fetches the Unspent Transaction Outputs (UTXOs) for a given Bitcoin address.\n   *\n   * @param {string} address - The Bitcoin address for which to fetch the UTXOs.\n   * @returns {Promise<Array<{ txid: string; vout: number; value: number }>>} A promise that resolves to an array of UTXOs.\n   * Each UTXO is represented as an object containing the transaction ID (`txid`), the output index within that transaction (`vout`),\n   * and the value of the output in satoshis (`value`).\n   */ async fetchUTXOs(address) {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/address/\").concat(address, \"/utxo\"));\n        const utxos = response.data.map((utxo)=>({\n                txid: utxo.txid,\n                vout: utxo.vout,\n                value: utxo.value,\n                script: utxo.script\n            }));\n        return utxos;\n    }\n    /**\n   * Fetches a Bitcoin transaction by its ID and constructs a transaction object.\n   * This function retrieves the transaction details from the blockchain using the RPC endpoint,\n   * then parses the input and output data to construct a `bitcoin.Transaction` object.\n   *\n   * @param {string} transactionId - The ID of the transaction to fetch.\n   * @returns {Promise<bitcoin.Transaction>} A promise that resolves to a `bitcoin.Transaction` object representing the fetched transaction.\n   */ async fetchTransaction(transactionId) {\n        const { data } = await axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].get(\"\".concat(this.chain_rpc, \"/tx/\").concat(transactionId));\n        const tx = new bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.Transaction();\n        tx.version = data.version;\n        tx.locktime = data.locktime;\n        data.vin.forEach((vin)=>{\n            const txHash = Buffer.from(vin.txid, \"hex\").reverse();\n            const vout = vin.vout;\n            const sequence = vin.sequence;\n            const scriptSig = vin.scriptsig ? Buffer.from(vin.scriptsig, \"hex\") : undefined;\n            tx.addInput(txHash, vout, sequence, scriptSig);\n        });\n        data.vout.forEach((vout)=>{\n            const value = vout.value;\n            const scriptPubKey = Buffer.from(vout.scriptpubkey, \"hex\");\n            tx.addOutput(scriptPubKey, value);\n        });\n        data.vin.forEach((vin, index)=>{\n            if (vin.witness && vin.witness.length > 0) {\n                const witness = vin.witness.map((w)=>Buffer.from(w, \"hex\"));\n                tx.setWitness(index, witness);\n            }\n        });\n        return tx;\n    }\n    /**\n   * Initializes a new instance of the `Bitcoin` class.\n   *\n   * @param {string} chain_rpc - The URL of the Bitcoin Core RPC endpoint.\n   * @param {string} network - The network to use. Either \"mainnet\" or \"testnet\".\n   */ constructor(chain_rpc, network){\n        this.chain_rpc = chain_rpc;\n        this.network = network === \"testnet\" ? bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.networks.testnet : bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_0__.networks.bitcoin;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sR0FBR0EsWUFBWSxZQUFZVixtREFBZ0IsQ0FBQ29ILE9BQU8sR0FBR3BILG1EQUFnQixDQUFDQSxPQUFPO0lBQzVGO0FBb05GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYml0Y29pbi50cz85MTg4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgKiBhcyBldGhlcnMgZnJvbSAnZXRoZXJzJztcbmltcG9ydCAqIGFzIGJpdGNvaW4gZnJvbSBcImJpdGNvaW5qcy1saWJcIjtcbmltcG9ydCB7IGRlcml2ZUNoaWxkUHVibGljS2V5LCBuYWpQdWJsaWNLZXlTdHJUb1VuY29tcHJlc3NlZEhleFBvaW50LCB1bmNvbXByZXNzZWRIZXhQb2ludFRvQnRjQWRkcmVzcyB9IGZyb20gJ0AvbGliL2tkZic7XG5cbmV4cG9ydCBjbGFzcyBCaXRjb2luIHtcbiAgY2hhaW5fcnBjOiBzdHJpbmc7XG4gIG5ldHdvcms6IGJpdGNvaW4uTmV0d29yaztcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgQml0Y29pbmAgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbl9ycGMgLSBUaGUgVVJMIG9mIHRoZSBCaXRjb2luIENvcmUgUlBDIGVuZHBvaW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIFRoZSBuZXR3b3JrIHRvIHVzZS4gRWl0aGVyIFwibWFpbm5ldFwiIG9yIFwidGVzdG5ldFwiLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2hhaW5fcnBjOiBzdHJpbmcsIG5ldHdvcms6IHN0cmluZykge1xuICAgIHRoaXMuY2hhaW5fcnBjID0gY2hhaW5fcnBjO1xuICAgIHRoaXMubmV0d29yayA9IG5ldHdvcmsgPT09ICd0ZXN0bmV0JyA/IGJpdGNvaW4ubmV0d29ya3MudGVzdG5ldCA6IGJpdGNvaW4ubmV0d29ya3MuYml0Y29pbjtcbiAgfVxuXG4gIGFzeW5jIGRlcml2ZUFkZHJlc3MoYWNjb3VudElkOiBzdHJpbmcsIGRlcml2YXRpb25fcGF0aDogc3RyaW5nKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgZGVyaXZlQ2hpbGRQdWJsaWNLZXkobmFqUHVibGljS2V5U3RyVG9VbmNvbXByZXNzZWRIZXhQb2ludCgpLCBhY2NvdW50SWQsIGRlcml2YXRpb25fcGF0aCk7XG4gICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHVuY29tcHJlc3NlZEhleFBvaW50VG9CdGNBZGRyZXNzKHB1YmxpY0tleSwgdGhpcy5uZXR3b3JrKTtcbiAgICByZXR1cm4geyBwdWJsaWNLZXk6IEJ1ZmZlci5mcm9tKHB1YmxpY0tleSwgJ2hleCcpLCBhZGRyZXNzIH07XG4gIH1cblxuICBhc3luYyBnZXRCYWxhbmNlKGFkZHJlc3M6IGFueSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KFxuICAgICAgYCR7dGhpcy5jaGFpbl9ycGN9L2FkZHJlc3MvJHthZGRyZXNzfS91dHhvYFxuICAgICk7XG4gICAgY29uc3QgYmFsYW5jZSA9IHJlc3BvbnNlLmRhdGEucmVkdWNlKChhY2M6IGFueSwgdXR4bzogeyB2YWx1ZTogYW55OyB9KSA9PiBhY2MgKyB1dHhvLnZhbHVlLCAwKTtcbiAgICByZXR1cm4gYmFsYW5jZTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVBheWxvYWQoc2VuZGVyOiBhbnksIHJlY2VpdmVyOiBhbnksIHNhdG9zaGlzOiBhbnkpIHtcbiAgICBjb25zdCB1dHhvcyA9IGF3YWl0IHRoaXMuZmV0Y2hVVFhPcyhzZW5kZXIpO1xuICAgIGNvbnN0IGZlZVJhdGUgPSBhd2FpdCB0aGlzLmZldGNoRmVlUmF0ZSgpO1xuXG4gICAgY29uc3QgcHNidCA9IG5ldyBiaXRjb2luLlBzYnQoeyBuZXR3b3JrOiB0aGlzLm5ldHdvcmsgfSk7XG5cbiAgICBsZXQgdG90YWxJbnB1dCA9IDA7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB1dHhvcy5tYXAoXG4gICAgICAgIGFzeW5jICh1dHhvOiB7IHZhbHVlOiBudW1iZXI7IHR4aWQ6IHN0cmluZzsgdm91dDogc3RyaW5nIHwgbnVtYmVyOyB9KSA9PiB7XG4gICAgICAgICAgdG90YWxJbnB1dCArPSB1dHhvLnZhbHVlO1xuXG4gICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLmZldGNoVHJhbnNhY3Rpb24odXR4by50eGlkKTtcbiAgICAgICAgICBjb25zdCBpbnB1dE9wdGlvbnMgPSB0cmFuc2FjdGlvbi5vdXRzW3V0eG8udm91dCBhcyBudW1iZXJdLnNjcmlwdC5pbmNsdWRlcyhcIjAwMTRcIikgP1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBoYXNoOiB1dHhvLnR4aWQsXG4gICAgICAgICAgICAgIGluZGV4OiB1dHhvLnZvdXQgYXMgbnVtYmVyLFxuICAgICAgICAgICAgICB3aXRuZXNzVXR4bzoge1xuICAgICAgICAgICAgICAgIHNjcmlwdDogdHJhbnNhY3Rpb24ub3V0c1t1dHhvLnZvdXQgYXMgbnVtYmVyXS5zY3JpcHQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHV0eG8udmFsdWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9IDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGFzaDogdXR4by50eGlkLFxuICAgICAgICAgICAgICBpbmRleDogdXR4by52b3V0IGFzIG51bWJlcixcbiAgICAgICAgICAgICAgbm9uV2l0bmVzc1V0eG86IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnRvSGV4KCksIFwiaGV4XCIpLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgcHNidC5hZGRJbnB1dChpbnB1dE9wdGlvbnMpO1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgICBwc2J0LmFkZE91dHB1dCh7XG4gICAgICBhZGRyZXNzOiByZWNlaXZlcixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc2F0b3NoaXMpLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZXN0aW1hdGVkU2l6ZSA9IHV0eG9zLmxlbmd0aCAqIDE0OCArIDIgKiAzNCArIDEwO1xuICAgIGNvbnN0IGZlZSA9IE1hdGguY2VpbChlc3RpbWF0ZWRTaXplICogKGZlZVJhdGUgKyAzKSk7XG5cbiAgICBjb25zdCBjaGFuZ2UgPSB0b3RhbElucHV0IC0gTnVtYmVyKHNhdG9zaGlzKSAtIGZlZTtcbiAgICBpZiAoY2hhbmdlID4gMCkge1xuICAgICAgcHNidC5hZGRPdXRwdXQoe1xuICAgICAgICBhZGRyZXNzOiBzZW5kZXIsXG4gICAgICAgIHZhbHVlOiBjaGFuZ2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwc2J0LCB1dHhvcyB9O1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdFNpZ25hdHVyZVRvTVBDKHdhbGxldDogeyBjYWxsTWV0aG9kOiAoYXJnMDogeyBjb250cmFjdElkOiBhbnk7IG1ldGhvZDogc3RyaW5nOyBhcmdzOiB7IHBheWxvYWQ6IG51bWJlcltdOyBwYXRoOiBhbnk7IGtleV92ZXJzaW9uOiBudW1iZXI7IH07IGdhczogc3RyaW5nOyB9KSA9PiBQcm9taXNlTGlrZTxbYW55LCBhbnldPiB8IFthbnksIGFueV07IH0sIGNvbnRyYWN0SWQ6IGFueSwgcGF0aDogYW55LCBidGNQYXlsb2FkOiB7IHBzYnQ6IGFueTsgdXR4b3M6IGFueTsgfSwgcHVibGljS2V5OiBhbnkpIHtcbiAgICBjb25zdCB7IHBzYnQsIHV0eG9zIH0gPSBidGNQYXlsb2FkO1xuXG4gICAgLy8gQml0Y29pbiBuZWVkcyB0byBzaWduIG11bHRpcGxlIHV0eG9zLCBzbyB3ZSBuZWVkIHRvIHBhc3MgYSBzaWduZXIgZnVuY3Rpb25cbiAgICBjb25zdCBzaWduID0gYXN5bmMgKHR4OiBldGhlcnMuZXRoZXJzLkJ5dGVzTGlrZSkgPT4ge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IEFycmF5LmZyb20oZXRoZXJzLmdldEJ5dGVzKHR4KSkucmV2ZXJzZSgpO1xuICAgICAgY29uc3QgW2JpZ19yLCBiaWdfc10gPSBhd2FpdCB3YWxsZXQuY2FsbE1ldGhvZCh7IGNvbnRyYWN0SWQsIG1ldGhvZDogJ3NpZ24nLCBhcmdzOiB7IHBheWxvYWQsIHBhdGgsIGtleV92ZXJzaW9uOiAwIH0sIGdhczogJzI1MDAwMDAwMDAwMDAwMCcgfSk7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvbnN0cnVjdFNpZ25hdHVyZShiaWdfciwgYmlnX3MpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdXR4b3MubWFwKGFzeW5jIChfOiBhbnksIGluZGV4OiBhbnkpID0+IHtcbiAgICAgICAgYXdhaXQgcHNidC5zaWduSW5wdXRBc3luYyhpbmRleCwgeyBwdWJsaWNLZXksIHNpZ24gfSk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBwc2J0LmZpbmFsaXplQWxsSW5wdXRzKCk7XG5cbiAgICByZXR1cm4gcHNidC5leHRyYWN0VHJhbnNhY3Rpb24oKS50b0hleCgpXG4gIH1cblxuICByZWNvbnN0cnVjdFNpZ25hdHVyZShiaWdfcjogc3RyaW5nLCBiaWdfczogc3RyaW5nKSB7XG4gICAgY29uc3QgciA9IGJpZ19yLnNsaWNlKDIpLnBhZFN0YXJ0KDY0LCBcIjBcIik7XG4gICAgY29uc3QgcyA9IGJpZ19zLnBhZFN0YXJ0KDY0LCBcIjBcIik7XG5cbiAgICBjb25zdCByYXdTaWduYXR1cmUgPSBCdWZmZXIuZnJvbShyICsgcywgXCJoZXhcIik7XG5cbiAgICBpZiAocmF3U2lnbmF0dXJlLmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlIGxlbmd0aC5cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd1NpZ25hdHVyZTtcbiAgfVxuXG4gIC8vIFRoaXMgY29kZSBjYW4gYmUgdXNlZCB0byBhY3R1YWxseSByZWxheSB0aGUgdHJhbnNhY3Rpb24gdG8gdGhlIEV0aGVyZXVtIG5ldHdvcmtcbiAgYXN5bmMgcmVsYXlUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbjogYW55LCB1c2VQcm94eSA9IHRydWUpIHtcbiAgICBjb25zdCBwcm94eSA9IHVzZVByb3h5ID8gXCJodHRwczovL2NvcnNwcm94eS5pby8/XCIgOiBcIlwiO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KFxuICAgICAgYCR7cHJveHl9JHt0aGlzLmNoYWluX3JwY30vdHhgLFxuICAgICAgc2lnbmVkVHJhbnNhY3Rpb25cbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSB2YWx1ZSBmcm9tIHNhdG9zaGlzIHRvIGJpdGNvaW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2F0b3NoaSAtIFRoZSBhbW91bnQgaW4gc2F0b3NoaXMgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGVxdWl2YWxlbnQgYW1vdW50IGluIGJpdGNvaW5zLlxuICAgKi9cbiAgc3RhdGljIHRvQlRDKHNhdG9zaGk6IG51bWJlcikge1xuICAgIHJldHVybiBzYXRvc2hpIC8gMTAwMDAwMDAwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgdmFsdWUgZnJvbSBiaXRjb2lucyB0byBzYXRvc2hpcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ0YyAtIFRoZSBhbW91bnQgaW4gYml0Y29pbnMgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGVxdWl2YWxlbnQgYW1vdW50IGluIHNhdG9zaGlzLlxuICAgKi9cbiAgc3RhdGljIHRvU2F0b3NoaShidGM6IG51bWJlcikge1xuICAgIHJldHVybiBOdW1iZXIoYnRjICogMTAwMDAwMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSBjdXJyZW50IGZlZSByYXRlIGZyb20gdGhlIEJpdGNvaW4gbmV0d29yay5cbiAgICogVGhpcyBtZXRob2QgcXVlcmllcyB0aGUgUlBDIGVuZHBvaW50IGZvciBmZWUgZXN0aW1hdGVzIGFuZCByZXR1cm5zIHRoZSBmZWUgcmF0ZVxuICAgKiBleHBlY3RlZCBmb3IgYSB0cmFuc2FjdGlvbiB0byBiZSBjb25maXJtZWQgd2l0aGluIGEgY2VydGFpbiBudW1iZXIgb2YgYmxvY2tzLlxuICAgKiBUaGUgY29uZmlybWF0aW9uIHRhcmdldCBpcyBzZXQgdG8gNiBibG9ja3MgYnkgZGVmYXVsdCwgd2hpY2ggaXMgY29tbW9ubHkgdXNlZFxuICAgKiBmb3IgYSBiYWxhbmNlIGJldHdlZW4gY29uZmlybWF0aW9uIHRpbWUgYW5kIGNvc3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmZWUgcmF0ZSBpbiBzYXRvc2hpcyBwZXIgYnl0ZS5cbiAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgZmVlIHJhdGUgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBjb25maXJtYXRpb24gdGFyZ2V0IGlzIG1pc3NpbmcuXG4gICAqL1xuICBhc3luYyBmZXRjaEZlZVJhdGUoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7dGhpcy5jaGFpbl9ycGN9L2ZlZS1lc3RpbWF0ZXNgKTtcbiAgICBjb25zdCBjb25maXJtYXRpb25UYXJnZXQgPSA2O1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhW2NvbmZpcm1hdGlvblRhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgVW5zcGVudCBUcmFuc2FjdGlvbiBPdXRwdXRzIChVVFhPcykgZm9yIGEgZ2l2ZW4gQml0Y29pbiBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBCaXRjb2luIGFkZHJlc3MgZm9yIHdoaWNoIHRvIGZldGNoIHRoZSBVVFhPcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8eyB0eGlkOiBzdHJpbmc7IHZvdXQ6IG51bWJlcjsgdmFsdWU6IG51bWJlciB9Pj59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIFVUWE9zLlxuICAgKiBFYWNoIFVUWE8gaXMgcmVwcmVzZW50ZWQgYXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRyYW5zYWN0aW9uIElEIChgdHhpZGApLCB0aGUgb3V0cHV0IGluZGV4IHdpdGhpbiB0aGF0IHRyYW5zYWN0aW9uIChgdm91dGApLFxuICAgKiBhbmQgdGhlIHZhbHVlIG9mIHRoZSBvdXRwdXQgaW4gc2F0b3NoaXMgKGB2YWx1ZWApLlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hVVFhPcyhhZGRyZXNzOiBhbnkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgIGAke3RoaXMuY2hhaW5fcnBjfS9hZGRyZXNzLyR7YWRkcmVzc30vdXR4b2BcbiAgICApO1xuXG4gICAgY29uc3QgdXR4b3MgPSByZXNwb25zZS5kYXRhLm1hcCgodXR4bzogeyB0eGlkOiBhbnk7IHZvdXQ6IGFueTsgdmFsdWU6IGFueTsgc2NyaXB0OiBhbnk7IH0pID0+ICh7XG4gICAgICB0eGlkOiB1dHhvLnR4aWQsXG4gICAgICB2b3V0OiB1dHhvLnZvdXQsXG4gICAgICB2YWx1ZTogdXR4by52YWx1ZSxcbiAgICAgIHNjcmlwdDogdXR4by5zY3JpcHQsXG4gICAgfSkpO1xuICAgIHJldHVybiB1dHhvcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGEgQml0Y29pbiB0cmFuc2FjdGlvbiBieSBpdHMgSUQgYW5kIGNvbnN0cnVjdHMgYSB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAqIFRoaXMgZnVuY3Rpb24gcmV0cmlldmVzIHRoZSB0cmFuc2FjdGlvbiBkZXRhaWxzIGZyb20gdGhlIGJsb2NrY2hhaW4gdXNpbmcgdGhlIFJQQyBlbmRwb2ludCxcbiAgICogdGhlbiBwYXJzZXMgdGhlIGlucHV0IGFuZCBvdXRwdXQgZGF0YSB0byBjb25zdHJ1Y3QgYSBgYml0Y29pbi5UcmFuc2FjdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNhY3Rpb25JZCAtIFRoZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gZmV0Y2guXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJpdGNvaW4uVHJhbnNhY3Rpb24+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGBiaXRjb2luLlRyYW5zYWN0aW9uYCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBmZXRjaGVkIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklkOiBhbnkpIHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLmdldChcbiAgICAgIGAke3RoaXMuY2hhaW5fcnBjfS90eC8ke3RyYW5zYWN0aW9uSWR9YFxuICAgICk7XG4gICAgY29uc3QgdHggPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbigpO1xuXG4gICAgdHgudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcbiAgICB0eC5sb2NrdGltZSA9IGRhdGEubG9ja3RpbWU7XG5cbiAgICBkYXRhLnZpbi5mb3JFYWNoKCh2aW46IHsgdHhpZDogV2l0aEltcGxpY2l0Q29lcmNpb248c3RyaW5nPiB8IHsgW1N5bWJvbC50b1ByaW1pdGl2ZV0oaGludDogXCJzdHJpbmdcIik6IHN0cmluZzsgfTsgdm91dDogYW55OyBzZXF1ZW5jZTogYW55OyBzY3JpcHRzaWc6IFdpdGhJbXBsaWNpdENvZXJjaW9uPHN0cmluZz4gfCB7IFtTeW1ib2wudG9QcmltaXRpdmVdKGhpbnQ6IFwic3RyaW5nXCIpOiBzdHJpbmc7IH07IH0pID0+IHtcbiAgICAgIGNvbnN0IHR4SGFzaCA9IEJ1ZmZlci5mcm9tKHZpbi50eGlkLCBcImhleFwiKS5yZXZlcnNlKCk7XG4gICAgICBjb25zdCB2b3V0ID0gdmluLnZvdXQ7XG4gICAgICBjb25zdCBzZXF1ZW5jZSA9IHZpbi5zZXF1ZW5jZTtcbiAgICAgIGNvbnN0IHNjcmlwdFNpZyA9IHZpbi5zY3JpcHRzaWdcbiAgICAgICAgPyBCdWZmZXIuZnJvbSh2aW4uc2NyaXB0c2lnLCBcImhleFwiKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIHR4LmFkZElucHV0KHR4SGFzaCwgdm91dCwgc2VxdWVuY2UsIHNjcmlwdFNpZyk7XG4gICAgfSk7XG5cbiAgICBkYXRhLnZvdXQuZm9yRWFjaCgodm91dDogeyB2YWx1ZTogYW55OyBzY3JpcHRwdWJrZXk6IFdpdGhJbXBsaWNpdENvZXJjaW9uPHN0cmluZz4gfCB7IFtTeW1ib2wudG9QcmltaXRpdmVdKGhpbnQ6IFwic3RyaW5nXCIpOiBzdHJpbmc7IH07IH0pID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdm91dC52YWx1ZTtcbiAgICAgIGNvbnN0IHNjcmlwdFB1YktleSA9IEJ1ZmZlci5mcm9tKHZvdXQuc2NyaXB0cHVia2V5LCBcImhleFwiKTtcbiAgICAgIHR4LmFkZE91dHB1dChzY3JpcHRQdWJLZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIGRhdGEudmluLmZvckVhY2goKHZpbjogeyB3aXRuZXNzOiBhbnlbXTsgfSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKHZpbi53aXRuZXNzICYmIHZpbi53aXRuZXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgd2l0bmVzcyA9IHZpbi53aXRuZXNzLm1hcCgodzogV2l0aEltcGxpY2l0Q29lcmNpb248c3RyaW5nPiB8IHsgW1N5bWJvbC50b1ByaW1pdGl2ZV0oaGludDogXCJzdHJpbmdcIik6IHN0cmluZzsgfSkgPT4gQnVmZmVyLmZyb20odywgXCJoZXhcIikpO1xuICAgICAgICB0eC5zZXRXaXRuZXNzKGluZGV4LCB3aXRuZXNzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0eDtcbiAgfVxufSJdLCJuYW1lcyI6WyJheGlvcyIsImV0aGVycyIsImJpdGNvaW4iLCJkZXJpdmVDaGlsZFB1YmxpY0tleSIsIm5halB1YmxpY0tleVN0clRvVW5jb21wcmVzc2VkSGV4UG9pbnQiLCJ1bmNvbXByZXNzZWRIZXhQb2ludFRvQnRjQWRkcmVzcyIsIkJpdGNvaW4iLCJkZXJpdmVBZGRyZXNzIiwiYWNjb3VudElkIiwiZGVyaXZhdGlvbl9wYXRoIiwicHVibGljS2V5IiwiYWRkcmVzcyIsIm5ldHdvcmsiLCJCdWZmZXIiLCJmcm9tIiwiZ2V0QmFsYW5jZSIsInJlc3BvbnNlIiwiZ2V0IiwiY2hhaW5fcnBjIiwiYmFsYW5jZSIsImRhdGEiLCJyZWR1Y2UiLCJhY2MiLCJ1dHhvIiwidmFsdWUiLCJjcmVhdGVQYXlsb2FkIiwic2VuZGVyIiwicmVjZWl2ZXIiLCJzYXRvc2hpcyIsInV0eG9zIiwiZmV0Y2hVVFhPcyIsImZlZVJhdGUiLCJmZXRjaEZlZVJhdGUiLCJwc2J0IiwiUHNidCIsInRvdGFsSW5wdXQiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwidHJhbnNhY3Rpb24iLCJmZXRjaFRyYW5zYWN0aW9uIiwidHhpZCIsImlucHV0T3B0aW9ucyIsIm91dHMiLCJ2b3V0Iiwic2NyaXB0IiwiaW5jbHVkZXMiLCJoYXNoIiwiaW5kZXgiLCJ3aXRuZXNzVXR4byIsIm5vbldpdG5lc3NVdHhvIiwidG9IZXgiLCJhZGRJbnB1dCIsImFkZE91dHB1dCIsIk51bWJlciIsImVzdGltYXRlZFNpemUiLCJsZW5ndGgiLCJmZWUiLCJNYXRoIiwiY2VpbCIsImNoYW5nZSIsInJlcXVlc3RTaWduYXR1cmVUb01QQyIsIndhbGxldCIsImNvbnRyYWN0SWQiLCJwYXRoIiwiYnRjUGF5bG9hZCIsInNpZ24iLCJ0eCIsInBheWxvYWQiLCJBcnJheSIsImdldEJ5dGVzIiwicmV2ZXJzZSIsImJpZ19yIiwiYmlnX3MiLCJjYWxsTWV0aG9kIiwibWV0aG9kIiwiYXJncyIsImtleV92ZXJzaW9uIiwiZ2FzIiwicmVjb25zdHJ1Y3RTaWduYXR1cmUiLCJfIiwic2lnbklucHV0QXN5bmMiLCJmaW5hbGl6ZUFsbElucHV0cyIsImV4dHJhY3RUcmFuc2FjdGlvbiIsInIiLCJzbGljZSIsInBhZFN0YXJ0IiwicyIsInJhd1NpZ25hdHVyZSIsIkVycm9yIiwicmVsYXlUcmFuc2FjdGlvbiIsInNpZ25lZFRyYW5zYWN0aW9uIiwidXNlUHJveHkiLCJwcm94eSIsInBvc3QiLCJ0b0JUQyIsInNhdG9zaGkiLCJ0b1NhdG9zaGkiLCJidGMiLCJjb25maXJtYXRpb25UYXJnZXQiLCJ0cmFuc2FjdGlvbklkIiwiVHJhbnNhY3Rpb24iLCJ2ZXJzaW9uIiwibG9ja3RpbWUiLCJ2aW4iLCJmb3JFYWNoIiwidHhIYXNoIiwic2VxdWVuY2UiLCJzY3JpcHRTaWciLCJzY3JpcHRzaWciLCJ1bmRlZmluZWQiLCJzY3JpcHRQdWJLZXkiLCJzY3JpcHRwdWJrZXkiLCJ3aXRuZXNzIiwidyIsInNldFdpdG5lc3MiLCJjb25zdHJ1Y3RvciIsIm5ldHdvcmtzIiwidGVzdG5ldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/bitcoin.ts\n"));

/***/ })

});